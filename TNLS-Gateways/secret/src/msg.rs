use cosmwasm_std::{
    from_binary, Api, Binary, Extern, HumanAddr, Querier, StdError, StdResult, Storage,
};
use secret_toolkit::utils::HandleCallback;

use crate::types::*;

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use chacha20poly1305::aead::{Aead, NewAead};
use chacha20poly1305::{ChaCha20Poly1305, Nonce};
use secp256k1::{ecdh::SharedSecret, PublicKey, SecretKey};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InitMsg {
    /// Entropy used for Prng seed.
    pub entropy: String,
    /// Optional admin address, env.message.sender if missing.
    pub admin: Option<HumanAddr>,
    pub rng_hash: String,
    pub rng_addr: HumanAddr,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum HandleMsg {
    /// Triggers the scrt-rng contract to send back previously requested randomness.
    KeyGen {
        rng_hash: String,
        rng_addr: HumanAddr,
    },
    /// Receives the callback message from scrt-rng. Actual key generation happens at this step.
    ReceiveFRn {
        cb_msg: Binary,
        purpose: Option<String>,
        rn: [u8; 32],
    },
    /// Process an interchain message through the private gateway.
    Input {
        inputs: PreExecutionMsg,
    },
    /// Receive results from private contract and broadcast logs for Relayer.
    Output {
        outputs: PostExecutionMsg,
    },
}

#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema, Debug)]
#[serde(rename_all = "snake_case")]
pub enum ResponseStatus {
    Success,
    Failure,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub struct InputResponse {
    pub status: ResponseStatus,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    /// Query the gateway's public keys.
    GetPublicKeys {},
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct PublicKeyResponse {
    /// Base64 encoded string.
    pub encryption_key: Binary,
    /// '0x' prefixed hex encoded byte string.
    pub verification_key: String,
}

/// Message received from the relayer.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct PreExecutionMsg {
    /// Task ID generated by the public gateway.
    pub task_id: u64,
    /// Source network (where to go once pulled into the next gateway).
    pub source_network: String,
    /// Destination contract address.
    pub routing_info: HumanAddr,
    /// Destination contract code hash.
    pub routing_code_hash: String,
    /// Encryption of (data, routing info, and user info).
    pub payload: Binary,
    /// Hash of encrypted input values.
    pub payload_hash: Binary,
    /// Signature of hash of encrypted input values.
    pub payload_signature: Binary,
    /// User public chain address.
    pub user_address: HumanAddr,
    /// User public key from payload encryption (not their wallet public key).
    pub user_key: Binary,
    /// Handle to be called at destination contract.
    pub handle: String,
    /// Unique random bytes used to encrypt payload.
    pub nonce: Binary,
}

impl PreExecutionMsg {
    pub fn verify<S: Storage, A: Api, Q: Querier>(&self, deps: &Extern<S, A, Q>) -> StdResult<()> {
        deps.api
            .secp256k1_verify(
                self.payload_hash.as_slice(),
                self.payload_signature.as_slice(),
                self.user_key.as_slice(),
            )
            .map_err(|err| StdError::generic_err(err.to_string()))?;
        Ok(())
    }
    pub fn decrypt_payload(&self, sk: Binary) -> StdResult<Payload> {
        let my_secret = SecretKey::from_slice(sk.as_slice())
            .map_err(|err| StdError::generic_err(err.to_string()))?;
        let their_public = PublicKey::from_slice(self.user_key.as_slice())
            .map_err(|err| StdError::generic_err(err.to_string()))?;
        let shared_key = SharedSecret::new(&their_public, &my_secret);
        let cipher = ChaCha20Poly1305::new_from_slice(shared_key.as_ref())
            .map_err(|err| StdError::generic_err(err.to_string()))?;
        let nonce = Nonce::from_slice(self.nonce.as_slice());
        let plaintext = cipher
            .decrypt(nonce, self.payload.as_slice())
            .map(Binary)
            .map_err(|err| StdError::generic_err(err.to_string()))?;
        let payload: Payload = from_binary(&plaintext)?;
        Ok(payload)
    }
}

/// Messages sent to other secret contracts.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum SecretMsg {
    CreateRn {
        cb_msg: Binary,
        entropy: String,
        max_blk_delay: Option<u64>,
        purpose: Option<String>,
        receiver_addr: Option<HumanAddr>,
        receiver_code_hash: String,
    },
    FulfillRn {
        creator_addr: HumanAddr,
        purpose: Option<String>,
        receiver_code_hash: String,
    },
    Input {
        message: PrivContractHandleMsg,
    },
}
impl HandleCallback for SecretMsg {
    const BLOCK_SIZE: usize = 256;
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct PrivContractHandleMsg {
    /// JSON string of decrypted user inputs.
    pub input_values: String,
    /// Handle function to be called in the destination contract.
    pub handle: String,
    /// Public network user address.
    pub user_address: HumanAddr,
    /// Task ID passed along for later verification.
    pub task_id: u64,
    /// SHA256 hash of `input_values`.
    pub input_hash: Binary,
    /// Signature of `input_hash`, signed by the private gateway.
    pub signature: Binary,
}

/// Message received from destination private contract with results.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct PostExecutionMsg {
    /// JSON string of results from the private contract.
    pub result: String,
    /// Task ID from private contract for verification.
    pub task_id: u64,
    /// SHA256 of decrypted (inputs + task ID) for verification.
    pub input_hash: Binary,
}

impl HandleCallback for PostExecutionMsg {
    const BLOCK_SIZE: usize = 256;
}

/// Message sent to the relayer.
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct BroadcastMsg {
    /// JSON string of results from the private contract.
    pub result: String,
    /// Encryption of (data, routing info, and user info).
    pub payload: Binary,
    /// Task ID coming from the gateway.
    pub task_id: u64,
    /// SHA256 hash of (result, packet, task_id).
    pub output_hash: Binary,
    /// `output_hash` signed with Private Gateway key.
    pub signature: Binary,
    /// Source network (where to go once pulled into the next gateway).
    pub routing_info: String,
}

impl HandleCallback for BroadcastMsg {
    const BLOCK_SIZE: usize = 256;
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ScrtRngMsg {
    CreateRn {
        cb_msg: Binary,
        entropy: String,
        max_blk_delay: Option<u64>,
        purpose: Option<String>,
        receiver_addr: Option<HumanAddr>,
        receiver_hash: String,
    },
    FulfullRn {
        creator_addr: HumanAddr,
        purpose: Option<String>,
        receiver_code_hash: String,
    },
}

impl HandleCallback for ScrtRngMsg {
    const BLOCK_SIZE: usize = 256;
}
