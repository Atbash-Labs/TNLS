
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/"/>

    <title>Performance tips and tricks &#8212; Atbash documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css"/>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/alabaster.css"/>
    <script data-url_root="../../../../../" id="documentation_options"
            src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html"/>
    <link rel="search" title="Search" href="../../../../../search.html"/>

    <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css"/>


    <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9"/>

</head>
<body>


<div class="document">
    <div class="documentwrapper">
        <div class="bodywrapper">


            <div class="body" role="main">

                <section id="performance-tips-and-tricks">
                    <span id="performance-tips"></span>
                    <h1>Performance tips and tricks<a class="headerlink" href="#performance-tips-and-tricks"
                                                      title="Permalink to this heading">¶</a></h1>
                    <p>Performance optimization is part art, part science. Just using mypyc
                        in a simple manner will likely make your code faster, but squeezing
                        the most performance out of your code requires the use of some
                        techniques we’ll summarize below.</p>
                    <section id="profiling">
                        <h2>Profiling<a class="headerlink" href="#profiling" title="Permalink to this heading">¶</a>
                        </h2>
                        <p>If you are speeding up existing code, understanding where time is
                            spent is important. Mypyc speeds up code that you compile. If most of
                            the time is spent elsewhere, you may come back disappointed. For
                            example, if you spend 40% of time outside compiled code, even if
                            compiled code would go 100x faster, overall performance will only be
                            2.5x faster.</p>
                        <p>A simple (but often effective) approach is to record the time in
                            various points of program execution using <code class="docutils literal notranslate"><span
                                    class="pre">time.time()</span></code>, and to
                            print out elapsed time (or to write it to a log file).</p>
                        <p>The stdlib modules <code class="docutils literal notranslate"><span
                                class="pre">profile</span></code> and <code class="docutils literal notranslate"><span
                                class="pre">cProfile</span></code> can provide much more
                            detailed data. (But these only work well with non-compiled code.)</p>
                    </section>
                    <section id="avoiding-slow-libraries">
                        <h2>Avoiding slow libraries<a class="headerlink" href="#avoiding-slow-libraries"
                                                      title="Permalink to this heading">¶</a></h2>
                        <p>If profiling indicates that a lot of time is spent in the stdlib or
                            third-party libraries, you still have several options.</p>
                        <p>First, if most time is spent in a few library features, you can
                            perhaps easily reimplement them in type-annotated Python, or extract
                            the relevant code and annotate it. Now it may be easy to compile this
                            code to speed it up.</p>
                        <p>Second, you may be able to avoid the library altogether, or use an
                            alternative, more efficient library to achieve the same purpose.</p>
                    </section>
                    <section id="type-annotations">
                        <h2>Type annotations<a class="headerlink" href="#type-annotations"
                                               title="Permalink to this heading">¶</a></h2>
                        <p>As discussed earlier, type annotations are key to major performance
                            gains. You should at least consider adding annotations to any
                            performance-critical functions and classes. It may also be helpful to
                            annotate code called by this code, even if it’s not compiled, since
                            this may help mypy infer better types in the compile code. If you use
                            libraries, ensure they have stub files with decent type annotation
                            coverage. Writing a stub file is often easy, and you only need to
                            annotate features you use a lot.</p>
                        <p>If annotating external code or writing stubs feel too burdensome, a
                            simple workaround is to annotate variables explicitly. For example,
                            here we call <code class="docutils literal notranslate"><span
                                    class="pre">acme.get_items()</span></code>, but it has no type annotation. We
                            can use an explicit type annotation for the variable to which we
                            assign the result:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span
                                    class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span
                                    class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">acme</span>

<span class="k">def</span> <span class="nf">work</span><span class="p">()</span> <span class="o">-&gt;</span> <span
                                        class="kc">None</span><span class="p">:</span>
    <span class="c1"># Annotate &quot;items&quot; to help mypyc</span>
    <span class="n">items</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span
                                        class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span
                                        class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span
                                        class="o">=</span> <span class="n">acme</span><span class="o">.</span><span
                                        class="n">get_items</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span
                                        class="p">:</span>
        <span class="o">...</span>  <span class="c1"># Do some work here</span>
</pre>
                            </div>
                        </div>
                        <p>Without the annotation on <code class="docutils literal notranslate"><span
                                class="pre">items</span></code>, the type would be <code
                                class="docutils literal notranslate"><span class="pre">Any</span></code> (since
                            <code class="docutils literal notranslate"><span class="pre">acme</span></code> has no type
                            annotation), resulting in slower, generic
                            operations being used later in the function.</p>
                    </section>
                    <section id="avoiding-slow-python-features">
                        <h2>Avoiding slow Python features<a class="headerlink" href="#avoiding-slow-python-features"
                                                            title="Permalink to this heading">¶</a></h2>
                        <p>Mypyc can optimize some features more effectively than others. Here
                            the difference is sometimes big – some things only get marginally
                            faster at best, while others can get 10x faster, or more. Avoiding
                            these slow features in performance-critical parts of your code can
                            help a lot.</p>
                        <p>These are some of the most important things to avoid:</p>
                        <ul class="simple">
                            <li><p>Using class decorators or metaclasses in compiled code (that aren’t
                                properly supported by mypyc)</p></li>
                            <li><p>Heavy reliance on interpreted Python libraries (C extensions are
                                usually fine)</p></li>
                        </ul>
                        <p>These things also tend to be relatively slow:</p>
                        <ul class="simple">
                            <li><p>Using Python classes and instances of Python classes (native classes
                                are much faster)</p></li>
                            <li><p>Calling decorated functions (<code class="docutils literal notranslate"><span
                                    class="pre">&#64;property</span></code>, <code class="docutils literal notranslate"><span
                                    class="pre">&#64;staticmethod</span></code>, and
                                <code class="docutils literal notranslate"><span
                                        class="pre">&#64;classmethod</span></code> are special cased and thus fast)</p>
                            </li>
                            <li><p>Calling nested functions</p></li>
                            <li><p>Calling functions or methods defined in other compilation units</p></li>
                            <li><p>Using <code class="docutils literal notranslate"><span
                                    class="pre">*args</span></code> or <code class="docutils literal notranslate"><span
                                    class="pre">**kwargs</span></code></p></li>
                            <li><p>Using generator functions</p></li>
                            <li><p>Using floating point numbers (they are relatively unoptimized)</p></li>
                            <li><p>Using callable values (i.e. not leveraging early binding to call
                                functions or methods)</p></li>
                        </ul>
                        <p>Nested functions can often be replaced with module-level functions or
                            methods of native classes.</p>
                        <p>Callable values and nested functions can sometimes be replaced with an
                            instance of a native class with a single method only, such as
                            <code class="docutils literal notranslate"><span class="pre">call(...)</span></code>. You
                            can derive the class from an ABC, if there are
                            multiple possible functions.</p>
                        <div class="admonition note">
                            <p class="admonition-title">Note</p>
                            <p>Some slow features will likely get efficient implementations in the
                                future. You should check this section every once in a while to see
                                if some additional operations are fast.</p>
                        </div>
                    </section>
                    <section id="using-fast-native-features">
                        <h2>Using fast native features<a class="headerlink" href="#using-fast-native-features"
                                                         title="Permalink to this heading">¶</a></h2>
                        <p>Some native operations are particularly quick relative to the
                            corresponding interpreted operations. Using them as much as possible
                            may allow you to see 10x or more in performance gains.</p>
                        <p>Some things are not much (or any) faster in compiled code, such as set
                            math operations. In contrast, calling a method of a native class is
                            much faster in compiled code.</p>
                        <p>If you are used to optimizing for CPython, you might have replaced
                            some class instances with dictionaries, as they can be
                            faster. However, in compiled code, this “optimization” would likely
                            slow down your code.</p>
                        <p>Similarly, caching a frequently called method in a local variable can
                            help in CPython, but it can slow things down in compiled code, since
                            the code won’t use <a class="reference internal"
                                                  href="differences_from_python.html#early-binding"><span
                                    class="std std-ref">early binding</span></a>:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="k">def</span> <span
                                    class="nf">squares</span><span class="p">(</span><span class="n">n</span><span
                                    class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span
                                    class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span
                                    class="nb">int</span><span class="p">]:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">append</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span
                                        class="n">append</span>  <span
                                        class="c1"># Not a good idea in compiled code!</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span
                                        class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">append</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span
                                        class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>
</pre>
                            </div>
                        </div>
                        <p>Here are examples of features that are fast, in no particular order
                            (this list is <em>not</em> exhaustive):</p>
                        <ul class="simple">
                            <li><p>Calling compiled functions directly defined in the same compilation
                                unit (with positional and/or keyword arguments)</p></li>
                            <li><p>Calling methods of native classes defined in the same compilation
                                unit (with positional and/or keyword arguments)</p></li>
                            <li><p>Many integer operations</p></li>
                            <li><p>Booleans</p></li>
                            <li><p><a class="reference internal" href="list_operations.html#list-ops"><span
                                    class="std std-ref">Native list operations</span></a>, such as indexing,
                                <code class="docutils literal notranslate"><span class="pre">append</span></code>, and
                                list comprehensions</p></li>
                            <li><p>While loops</p></li>
                            <li><p>For loops over ranges and lists, and with <code class="docutils literal notranslate"><span
                                    class="pre">enumerate</span></code> or <code
                                    class="docutils literal notranslate"><span class="pre">zip</span></code></p></li>
                            <li><p>Reading dictionary items</p></li>
                            <li><p><code class="docutils literal notranslate"><span
                                    class="pre">isinstance()</span></code> checks against native classes and instances
                                of
                                primitive types (and unions of them)</p></li>
                            <li><p>Accessing local variables</p></li>
                            <li><p>Accessing attributes of native classes</p></li>
                            <li><p>Accessing final module-level attributes</p></li>
                            <li><p>Comparing strings for equality</p></li>
                        </ul>
                        <p>These features are also fast, but somewhat less so (relative to other
                            related operations):</p>
                        <ul class="simple">
                            <li><p>Constructing instances of native classes</p></li>
                            <li><p>Constructing dictionaries</p></li>
                            <li><p>Setting dictionary items</p></li>
                            <li><p>Native <a class="reference internal" href="dict_operations.html#dict-ops"><span
                                    class="std std-ref">dict</span></a> and <a class="reference internal"
                                                                               href="set_operations.html#set-ops"><span
                                    class="std std-ref">set</span></a> operations</p></li>
                            <li><p>Accessing module-level variables</p></li>
                        </ul>
                        <p>Generally anything documented as a native operation is fast, even if
                            it’s not explicitly mentioned here</p>
                    </section>
                    <section id="adjusting-garbage-collection">
                        <h2>Adjusting garbage collection<a class="headerlink" href="#adjusting-garbage-collection"
                                                           title="Permalink to this heading">¶</a></h2>
                        <p>Compilation does not speed up cyclic garbage collection. If everything
                            else gets much faster, it’s possible that garbage collection will take
                            a big fraction of time. You can use <code class="docutils literal notranslate"><span
                                    class="pre">gc.set_threshold()</span></code> to adjust
                            the garbage collector to run less often:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="kn">import</span> <span
                                    class="nn">gc</span>

<span class="c1"># Spend less time in gc; do this before significant computation</span>
<span class="n">gc</span><span class="o">.</span><span class="n">set_threshold</span><span class="p">(</span><span
                                        class="mi">150000</span><span class="p">)</span>

<span class="o">...</span>  <span class="c1"># Actual work happens here</span>
</pre>
                            </div>
                        </div>
                    </section>
                    <section id="fast-interpreter-shutdown">
                        <h2>Fast interpreter shutdown<a class="headerlink" href="#fast-interpreter-shutdown"
                                                        title="Permalink to this heading">¶</a></h2>
                        <p>If you allocate many objects, it’s possible that your program spends a
                            lot of time cleaning up when the Python runtime shuts down. Mypyc
                            won’t speed up the shutdown of a Python process much.</p>
                        <p>You can call <code class="docutils literal notranslate"><span
                                class="pre">os._exit(code)</span></code> to immediately terminate the Python
                            process, skipping normal cleanup. This can give a nice boost to a
                            batch process or a command-line tool.</p>
                        <div class="admonition note">
                            <p class="admonition-title">Note</p>
                            <p>This can be dangerous and can lose data. You need to ensure
                                that all streams are flushed and everything is otherwise cleaned up
                                properly.</p>
                        </div>
                    </section>
                    <section id="work-smarter">
                        <h2>Work smarter<a class="headerlink" href="#work-smarter"
                                           title="Permalink to this heading">¶</a></h2>
                        <p>Usually there are many things you can do to improve performance, even
                            if most tweaks will yield only minor gains. The key to being effective
                            is to focus on things that give a large gain with a small effort.</p>
                        <p>For example, low-level optimizations, such as avoiding a nested
                            function, can be pointless, if you could instead avoid a metaclass –
                            to allow a key class to be compiled as a native class. The latter
                            optimization could speed up numerous method calls and attribute
                            accesses, just like that.</p>
                    </section>
                </section>


            </div>

        </div>
    </div>
    <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h1 class="logo"><a href="../../../../../index.html">Atbash</a></h1>


            <h3>Navigation</h3>

            <div class="relations">
                <h3>Related Topics</h3>
                <ul>
                    <li><a href="../../../../../index.html">Documentation overview</a>
                        <ul>
                        </ul>
                    </li>
                </ul>
            </div>
            <div id="searchbox" style="display: none" role="search">
                <h3 id="searchlabel">Quick search</h3>
                <div class="searchformwrapper">
                    <form class="search" action="../../../../../search.html" method="get">
                        <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off"
                               autocapitalize="off" spellcheck="false"/>
                        <input type="submit" value="Go"/>
                    </form>
                </div>
            </div>
            <script>document.getElementById('searchbox').style.display = "block"</script>


        </div>
    </div>
    <div class="clearer"></div>
</div>
<div class="footer">
    &copy;2022, Leor Fishman, Ben Simon, Kent Worcester, Prince Fefar.

    |
    Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
    &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>

    |
    <a href="../../../../../_sources/venv/Lib/site-packages/mypyc/doc/performance_tips_and_tricks.rst.txt"
       rel="nofollow">Page source</a>
</div>


</body>
</html>