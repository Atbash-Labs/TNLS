<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/"/>

    <title>Using type annotations &#8212; Atbash documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css"/>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/alabaster.css"/>
    <script data-url_root="../../../../../" id="documentation_options"
            src="../../../../../_static/documentation_options.js"></script>
    <script src="../../../../../_static/jquery.js"></script>
    <script src="../../../../../_static/underscore.js"></script>
    <script src="../../../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html"/>
    <link rel="search" title="Search" href="../../../../../search.html"/>

    <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css"/>


    <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9"/>

</head>
<body>


<div class="document">
    <div class="documentwrapper">
        <div class="bodywrapper">


            <div class="body" role="main">

                <section id="using-type-annotations">
                    <span id="id1"></span>
                    <h1>Using type annotations<a class="headerlink" href="#using-type-annotations"
                                                 title="Permalink to this heading">¶</a></h1>
                    <p>You will get the most out of mypyc if you compile code with precise
                        type annotations. Not all type annotations will help performance
                        equally, however. Using types such as <a class="reference internal"
                                                                 href="#primitive-types"><span class="std std-ref">primitive types</span></a>,
                        <a class="reference internal" href="#native-class-intro"><span class="std std-ref">native classes</span></a>,
                        <a class="reference internal" href="#union-types"><span
                                class="std std-ref">union types</span></a>, <a class="reference internal"
                                                                               href="#trait-types"><span
                                class="std std-ref">trait types</span></a>,
                        and <a class="reference internal" href="#tuple-types"><span
                                class="std std-ref">tuple types</span></a> as much as possible is a key to
                        major performance gains over CPython.</p>
                    <p>In contrast, some other types, including <code class="docutils literal notranslate"><span
                            class="pre">Any</span></code>, are treated as
                        <a class="reference internal" href="#erased-types"><span class="std std-ref">erased types</span></a>.
                        Operations on erased types use
                        generic operations that work with arbitrary objects, similar to how
                        the CPython interpreter works. If you only use erased types, the only
                        notable benefits over CPython will be the removal of interpreter
                        overhead (from compilation) and a bit of <a class="reference internal"
                                                                    href="differences_from_python.html#early-binding"><span
                                class="std std-ref">early binding</span></a>, which will usually only give minor
                        performance
                        gains.</p>
                    <section id="primitive-types">
                        <span id="id2"></span>
                        <h2>Primitive types<a class="headerlink" href="#primitive-types"
                                              title="Permalink to this heading">¶</a></h2>
                        <p>The following built-in types are treated as <em>primitive types</em> by
                            mypyc, and many operations on these types have efficient
                            implementations:</p>
                        <ul class="simple">
                            <li><p><code class="docutils literal notranslate"><span class="pre">int</span></code> (<a
                                    class="reference internal" href="int_operations.html#int-ops"><span
                                    class="std std-ref">native operations</span></a>)</p></li>
                            <li><p><code class="docutils literal notranslate"><span class="pre">float</span></code> (<a
                                    class="reference internal" href="float_operations.html#float-ops"><span
                                    class="std std-ref">native operations</span></a>)</p></li>
                            <li><p><code class="docutils literal notranslate"><span class="pre">bool</span></code> (<a
                                    class="reference internal" href="bool_operations.html#bool-ops"><span
                                    class="std std-ref">native operations</span></a>)</p></li>
                            <li><p><code class="docutils literal notranslate"><span class="pre">str</span></code> (<a
                                    class="reference internal" href="str_operations.html#str-ops"><span
                                    class="std std-ref">native operations</span></a>)</p></li>
                            <li><p><code class="docutils literal notranslate"><span class="pre">List[T]</span></code>
                                (<a class="reference internal" href="list_operations.html#list-ops"><span
                                        class="std std-ref">native operations</span></a>)</p></li>
                            <li><p><code class="docutils literal notranslate"><span class="pre">Dict[K,</span> <span
                                    class="pre">V]</span></code> (<a class="reference internal"
                                                                     href="dict_operations.html#dict-ops"><span
                                    class="std std-ref">native operations</span></a>)</p></li>
                            <li><p><code class="docutils literal notranslate"><span class="pre">Set[T]</span></code> (<a
                                    class="reference internal" href="set_operations.html#set-ops"><span
                                    class="std std-ref">native operations</span></a>)</p></li>
                            <li><p><code class="docutils literal notranslate"><span class="pre">Tuple[T,</span> <span
                                    class="pre">...]</span></code> (variable-length tuple; <a class="reference internal"
                                                                                              href="tuple_operations.html#tuple-ops"><span
                                    class="std std-ref">native operations</span></a>)</p></li>
                            <li><p><code class="docutils literal notranslate"><span class="pre">None</span></code></p>
                            </li>
                        </ul>
                        <p>The link after each type lists all supported native, optimized
                            operations for the type. You can use all operations supported by
                            Python, but <em>native operations</em> will have custom, optimized
                            implementations.</p>
                    </section>
                    <section id="primitive-containers">
                        <h2>Primitive containers<a class="headerlink" href="#primitive-containers"
                                                   title="Permalink to this heading">¶</a></h2>
                        <p>Primitive container objects such as <code class="docutils literal notranslate"><span
                                class="pre">list</span></code> and <code class="docutils literal notranslate"><span
                                class="pre">dict</span></code> don’t
                            maintain knowledge of the item types at runtime – the item type is
                            <em>erased</em>.</p>
                        <p>This means that item types are checked when items are accessed, not
                            when a container is passed as an argument or assigned to another
                            variable. For example, here we have a runtime type error on the final
                            line of <code class="docutils literal notranslate"><span class="pre">example</span></code>
                            (the <code class="docutils literal notranslate"><span class="pre">Any</span></code> type
                            means an arbitrary, unchecked
                            value):</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span
                                    class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span
                                    class="n">Any</span>

<span class="k">def</span> <span class="nf">example</span><span class="p">(</span><span class="n">a</span><span
                                        class="p">:</span> <span class="n">List</span><span class="p">[</span><span
                                        class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span
                                        class="kc">None</span><span class="p">:</span>
    <span class="n">b</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span
                                        class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span
                                        class="n">a</span>  <span class="c1"># No error -- items are not checked</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span
                                        class="mi">0</span><span class="p">])</span>  <span class="c1"># Error here -- got str, but expected int</span>

<span class="n">example</span><span class="p">([</span><span class="s2">&quot;x&quot;</span><span class="p">])</span>
</pre>
                            </div>
                        </div>
                    </section>
                    <section id="native-classes">
                        <span id="native-class-intro"></span>
                        <h2>Native classes<a class="headerlink" href="#native-classes"
                                             title="Permalink to this heading">¶</a></h2>
                        <p>Classes that get compiled to C extensions are called native
                            classes. Most common operations on instances of these classes are
                            optimized, including construction, attribute access and method calls.</p>
                        <p>Native class definitions look exactly like normal Python class
                            definitions. A class is usually native if it’s in a compiled module
                            (though there are some exceptions).</p>
                        <p>Consider this example:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="k">class</span> <span
                                    class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span
                                        class="p">,</span> <span class="n">x</span><span class="p">:</span> <span
                                        class="nb">int</span><span class="p">,</span> <span class="n">y</span><span
                                        class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span
                                        class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span
                                        class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span
                                        class="n">y</span>

<span class="k">def</span> <span class="nf">shift</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span
                                        class="n">Point</span><span class="p">)</span> <span
                                        class="o">-&gt;</span> <span class="n">Point</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">Point</span><span class="p">(</span><span class="n">p</span><span
                                        class="o">.</span><span class="n">x</span> <span class="o">+</span> <span
                                        class="mi">1</span><span class="p">,</span> <span class="n">p</span><span
                                        class="o">.</span><span class="n">y</span> <span class="o">+</span> <span
                                        class="mi">1</span><span class="p">)</span>
</pre>
                            </div>
                        </div>
                        <p>All operations in the above example use native operations, if the file
                            is compiled.</p>
                        <p>Native classes have some notable different from Python classes:</p>
                        <ul class="simple">
                            <li><p>Only attributes and methods defined in the class body or methods are
                                supported. If you try to assign to an undefined attribute outside
                                the class definition, <code class="docutils literal notranslate"><span class="pre">AttributeError</span></code>
                                will be raised. This enables
                                an efficient memory layout and fast method calls for native classes.</p></li>
                            <li><p>Native classes usually don’t define the <code
                                    class="docutils literal notranslate"><span class="pre">__dict__</span></code>
                                attribute (they
                                don’t have an attribute dictionary). This follows from only having
                                a specific set of attributes.</p></li>
                            <li><p>Native classes can’t have an arbitrary metaclass or use most class
                                decorators.</p></li>
                        </ul>
                        <p>Native classes only support single inheritance. A limited form of
                            multiple inheritance is supported through <em>trait types</em>. You generally
                            must inherit from another native class (or <code class="docutils literal notranslate"><span
                                    class="pre">object</span></code>). By default,
                            you can’t inherit a Python class from a native class (but there’s
                            an <a class="reference internal" href="native_classes.html#inheritance"><span
                                    class="std std-ref">override</span></a> to allow that).</p>
                        <p>See <a class="reference internal" href="native_classes.html#native-classes"><span
                                class="std std-ref">Native classes</span></a> for more details.</p>
                    </section>
                    <section id="tuple-types">
                        <span id="id3"></span>
                        <h2>Tuple types<a class="headerlink" href="#tuple-types" title="Permalink to this heading">¶</a>
                        </h2>
                        <p>Fixed-length
                            <a class="reference external"
                               href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#tuple-types">tuple
                                types</a>
                            such as <code class="docutils literal notranslate"><span class="pre">Tuple[int,</span> <span
                                    class="pre">str]</span></code> are represented
                            as <a class="reference internal" href="#value-and-heap-types"><span class="std std-ref">value types</span></a>
                            when stored in variables,
                            passed as arguments, or returned from functions. Value types are
                            allocated in the low-level machine stack or in CPU registers, as
                            opposed to <em>heap types</em>, which are allocated dynamically from the
                            heap.</p>
                        <p>Like all value types, tuples will be <em>boxed</em>, i.e. converted to
                            corresponding heap types, when stored in Python containers, or passed
                            to non-native code. A boxed tuple value will be a regular Python tuple
                            object.</p>
                    </section>
                    <section id="union-types">
                        <span id="id5"></span>
                        <h2>Union types<a class="headerlink" href="#union-types" title="Permalink to this heading">¶</a>
                        </h2>
                        <p><a class="reference external"
                              href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#union-types">Union
                            types</a>
                            and
                            <a class="reference external"
                               href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#optional-types-and-the-none-type">optional
                                types</a>
                            that contain primitive types, native class types and
                            trait types are also efficient. If a union type has
                            <a class="reference internal" href="#erased-types"><span
                                    class="std std-ref">erased</span></a> items, accessing items with
                            non-erased types is often still quite efficient.</p>
                        <p>A value with a union types is always <a class="reference internal"
                                                                   href="#value-and-heap-types"><span
                                class="std std-ref">boxed</span></a>,
                            even if it contains a value that also has an unboxed representation, such
                            as an integer or a boolean.</p>
                        <p>For example, using <code class="docutils literal notranslate"><span
                                class="pre">Optional[int]</span></code> is quite efficient, but the value
                            will always be boxed. A plain <code class="docutils literal notranslate"><span class="pre">int</span></code>
                            value will usually be faster, since
                            it has an unboxed representation.</p>
                    </section>
                    <section id="trait-types">
                        <span id="id7"></span>
                        <h2>Trait types<a class="headerlink" href="#trait-types" title="Permalink to this heading">¶</a>
                        </h2>
                        <p>Trait types enable a form of multiple inheritance for native classes.
                            A native class can inherit any number of traits. Trait types are
                            defined as classes using the <code class="docutils literal notranslate"><span class="pre">mypy_extensions.trait</span></code>
                            decorator:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mypy_extensions</span> <span
                                    class="kn">import</span> <span class="n">trait</span>

<span class="nd">@trait</span>
<span class="k">class</span> <span class="nc">MyTrait</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span
                                        class="p">)</span> <span class="o">-&gt;</span> <span
                                        class="kc">None</span><span class="p">:</span>
        <span class="o">...</span>
</pre>
                            </div>
                        </div>
                        <p>Traits can define methods, properties and attributes. They often
                            define abstract methods. Traits can be generic.</p>
                        <p>If a class subclasses both a non-trait class and traits, the traits
                            must be placed at the end of the base class list:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="k">class</span> <span
                                    class="nc">Base</span><span class="p">:</span> <span class="o">...</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">Base</span><span
                                        class="p">,</span> <span class="n">MyTrait</span><span class="p">,</span> <span
                                        class="n">FooTrait</span><span class="p">):</span>  <span class="c1"># OK</span>
    <span class="o">...</span>

<span class="k">class</span> <span class="nc">Derived2</span><span class="p">(</span><span class="n">MyTrait</span><span
                                        class="p">,</span> <span class="n">FooTrait</span><span class="p">,</span> <span
                                        class="n">Base</span><span class="p">):</span>
    <span class="c1"># Error: traits should come last</span>
    <span class="o">...</span>
</pre>
                            </div>
                        </div>
                        <p>Traits have some special properties:</p>
                        <ul class="simple">
                            <li><p>You shouldn’t create instances of traits (though mypyc does not
                                prevent it yet).</p></li>
                            <li><p>Traits can subclass other traits, but they can’t subclass non-trait
                                classes (other than <code class="docutils literal notranslate"><span
                                        class="pre">object</span></code>).</p></li>
                            <li><p>Accessing methods or attributes through a trait type is somewhat
                                less efficient than through a native class type, but this is much
                                faster than through Python class types or other
                                <a class="reference internal" href="#erased-types"><span class="std std-ref">erased types</span></a>.
                            </p></li>
                        </ul>
                        <p>You need to install <code class="docutils literal notranslate"><span class="pre">mypy-extensions</span></code>
                            to use <code class="docutils literal notranslate"><span class="pre">&#64;trait</span></code>:
                        </p>
                        <div class="highlight-text notranslate">
                            <div class="highlight"><pre><span></span>pip install --upgrade mypy-extensions
</pre>
                            </div>
                        </div>
                    </section>
                    <section id="erased-types">
                        <span id="id8"></span>
                        <h2>Erased types<a class="headerlink" href="#erased-types"
                                           title="Permalink to this heading">¶</a></h2>
                        <p>Mypyc supports many other kinds of types as well, beyond those
                            described above. However, these types don’t have customized
                            operations, and they are implemented using <em>type erasure</em>. Type
                            erasure means that all other types are equivalent to untyped values at
                            runtime, i.e. they are the equivalent of the type <code
                                    class="docutils literal notranslate"><span class="pre">Any</span></code>. Erased
                            types include these:</p>
                        <ul class="simple">
                            <li><p>Python classes (including ABCs)</p></li>
                            <li><p>Non-mypyc extension types and primitive types (including built-in
                                types that are not primitives)</p></li>
                            <li><p><a class="reference external"
                                      href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#callable-types-and-lambdas">Callable
                                types</a></p></li>
                            <li><p><a class="reference external"
                                      href="https://mypy.readthedocs.io/en/stable/generics.html">Type variable types</a>
                            </p></li>
                            <li><p>Type <a class="reference external"
                                           href="https://mypy.readthedocs.io/en/stable/dynamic_typing.html">Any</a></p>
                            </li>
                            <li><p>Protocol types</p></li>
                        </ul>
                        <p>Using erased types can still improve performance, since they can
                            enable better types to be inferred for expressions that use these
                            types. For example, a value with type <code class="docutils literal notranslate"><span
                                    class="pre">Callable[[],</span> <span class="pre">int]</span></code> will not
                            allow native calls. However, the return type is a primitive type, and
                            we can use fast operations on the return value:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span
                                    class="kn">import</span> <span class="n">Callable</span>

<span class="k">def</span> <span class="nf">call_and_inc</span><span class="p">(</span><span class="n">f</span><span
                                        class="p">:</span> <span class="n">Callable</span><span
                                        class="p">[[],</span> <span class="nb">int</span><span class="p">])</span> <span
                                        class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="c1"># Slow call, since f has an erased type</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span>
    <span class="c1"># Fast increment; inferred type of n is int (primitive type)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n</span>
</pre>
                            </div>
                        </div>
                        <p>If the type of the argument <code class="docutils literal notranslate"><span
                                class="pre">f</span></code> was <code class="docutils literal notranslate"><span
                                class="pre">Any</span></code>, the type of <code
                                class="docutils literal notranslate"><span class="pre">n</span></code> would
                            also be <code class="docutils literal notranslate"><span class="pre">Any</span></code>,
                            resulting in a generic, slower increment operation
                            being used.</p>
                    </section>
                    <section id="strict-runtime-type-checking">
                        <h2>Strict runtime type checking<a class="headerlink" href="#strict-runtime-type-checking"
                                                           title="Permalink to this heading">¶</a></h2>
                        <p>Compiled code ensures that any variable or expression with a
                            non-erased type only has compatible values at runtime. This is in
                            contrast with using <em>optional static typing</em>, such as by using mypy,
                            when type annotations are not enforced at runtime. Mypyc ensures
                            type safety both statically and at runtime.</p>
                        <p><code class="docutils literal notranslate"><span class="pre">Any</span></code> types and
                            erased types in general can compromise type safety,
                            and this is by design. Inserting strict runtime type checks for all
                            possible values would be too expensive and against the goal of
                            high performance.</p>
                    </section>
                    <section id="value-and-heap-types">
                        <span id="id9"></span>
                        <h2>Value and heap types<a class="headerlink" href="#value-and-heap-types"
                                                   title="Permalink to this heading">¶</a></h2>
                        <p>In CPython, memory for all objects is dynamically allocated on the
                            heap. All Python types are thus <em>heap types</em>. In compiled code, some
                            types are <em>value types</em> – no object is (necessarily) allocated on the
                            heap. <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code
                                    class="docutils literal notranslate"><span class="pre">None</span></code> and
                            fixed-length tuples are value types.</p>
                        <p><code class="docutils literal notranslate"><span class="pre">int</span></code> is a hybrid.
                            For typical integer values, it is a value
                            type. Large enough integer values, those that require more than 63
                            bits (or 31 bits on 32-bit platforms) to represent, use a heap-based
                            representation (same as CPython).</p>
                        <p>Value types have a few differences from heap types:</p>
                        <ul class="simple">
                            <li><p>When an instance of a value type is used in a context that expects a
                                heap value, for example as a list item, it will transparently switch
                                to a heap-based representation (boxing) as needed.</p></li>
                            <li><p>Similarly, mypyc transparently changes from a heap-based
                                representation to a value representation (unboxing).</p></li>
                            <li><p>Object identity of integers and tuples is not preserved. You should
                                use <code class="docutils literal notranslate"><span class="pre">==</span></code>
                                instead of <code class="docutils literal notranslate"><span class="pre">is</span></code>
                                if you are comparing two integers or
                                fixed-length tuples.</p></li>
                            <li><p>When an instance of a subclass of a value type is converted to the
                                base type, it is implicitly converted to an instance of the target
                                type. For example, a <code class="docutils literal notranslate"><span
                                        class="pre">bool</span></code> value assigned to a variable with an
                                <code class="docutils literal notranslate"><span class="pre">int</span></code> type will
                                be converted to the corresponding integer.</p></li>
                        </ul>
                        <p>The latter conversion is the only implicit type conversion that
                            happens in mypyc programs.</p>
                        <p>Example:</p>
                        <div class="highlight-default notranslate">
                            <div class="highlight"><pre><span></span><span class="k">def</span> <span
                                    class="nf">example</span><span class="p">()</span> <span
                                    class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># A small integer uses the value (unboxed) representation</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="c1"># A large integer the the heap (boxed) representation</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span
                                        class="mi">500</span>
    <span class="c1"># Lists always contain boxed integers</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">55</span><span class="p">]</span>
    <span class="c1"># When reading from a list, the object is automatically unboxed</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span
                                        class="mi">0</span><span class="p">]</span>
    <span class="c1"># True is converted to 1 on assignment</span>
    <span class="n">x</span> <span class="o">=</span> <span class="kc">True</span>
</pre>
                            </div>
                        </div>
                    </section>
                </section>


            </div>

        </div>
    </div>
    <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <h1 class="logo"><a href="../../../../../index.html">Atbash</a></h1>


            <h3>Navigation</h3>

            <div class="relations">
                <h3>Related Topics</h3>
                <ul>
                    <li><a href="../../../../../index.html">Documentation overview</a>
                        <ul>
                        </ul>
                    </li>
                </ul>
            </div>
            <div id="searchbox" style="display: none" role="search">
                <h3 id="searchlabel">Quick search</h3>
                <div class="searchformwrapper">
                    <form class="search" action="../../../../../search.html" method="get">
                        <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off"
                               autocapitalize="off" spellcheck="false"/>
                        <input type="submit" value="Go"/>
                    </form>
                </div>
            </div>
            <script>document.getElementById('searchbox').style.display = "block"</script>


        </div>
    </div>
    <div class="clearer"></div>
</div>
<div class="footer">
    &copy;2022, Leor Fishman, Ben Simon, Kent Worcester, Prince Fefar.

    |
    Powered by <a href="http://sphinx-doc.org/">Sphinx 5.1.1</a>
    &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>

    |
    <a href="../../../../../_sources/venv/Lib/site-packages/mypyc/doc/using_type_annotations.rst.txt"
       rel="nofollow">Page source</a>
</div>


</body>
</html>